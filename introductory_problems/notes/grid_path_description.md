### 題目意思
* 給定一個 7 × 7 的方格
* 起點在 左上角 `(0,0)`
* 終點在 左下角 `(6,0)`
* 必須走 剛好 48 步
  * 每一步是 `U / D / L / R` 
* 每一格只能走一次
* 輸入是一個長度 48 的字串
* 可能包含：
  * 固定方向：`U D L R`
  * 不確定方向：`?`（可選 4 個方向）
* 題目要求：有多少條路徑，能同時滿足字串限制與路徑規則

### 核心概念
* DFS + Backtracking
  * DFS 的狀態定義：
  ```cpp
  // step：表示目前已經走幾步
  // (x, y)：表示目前所在的位置
  dfs(step, x, y)
  ``` 
  * Backtracking 的意義：
  ```cpp
  // 走到某一格 -> 標記為已拜訪
  // 嘗試所有可能方向
  // 回來時 -> 取消標記
  visited[x][y] = true;
  dfs(...)
  visited[x][y] = false;
  ```
* 終止條件：
  * 出界
  * 走到已拜訪格
  * 太早到終點 `(6, 0)` 且 `step < 48`
  * 成功情況：`step == 48 && (x, y) == (6, 0)`
* 剪枝條件：如果某一步會把剩下的空格「切成兩塊」，就一定無解
  * 上下都被堵、左右是空的 &rarr; 剪
  * 左右都被堵、上下是空的 &rarr; 剪
  ```cpp
  if (up && down && !left && !right) return;
  if (!up && !down && left && right) return;
  ```

### 問題點
* 知道使用 DFS + Backtracking，但是不知道程式改怎麼下手
* 對 DFS 和 Backtracking 的架構不熟