### 題目意思
- 給你一個長度為 `n` 的排列（包含 `1..n` 每個數字恰好一次）。 
- 你要依序收集 `1,2,3,...,n`
- 每一輪（round）你都從陣列左到右掃一次，能收集就收集
- 接著有 `m` 次操作，每次交換陣列中兩個位置 `a, b` 的數字
- **每次交換後**都要輸出目前需要的 round 數

### 核心概念
#### rounds 的計算方式（用位置表 pos）

定義：

- `pos[x]`：數字 `x` 在陣列中的位置（index）

觀察相鄰數字 `i` 和 `i+1`：

- 若 `pos[i] < pos[i+1]`：在左到右掃描時會先遇到 `i` 再遇到 `i+1`  
  → 同一輪可以接著收集
- 若 `pos[i] > pos[i+1]`：會先遇到 `i+1` 才遇到 `i`  
  → `i+1` 必須等下一輪才能收集，這裡會多一輪

因此：
- 斷點（break）定義：`pos[i] > pos[i+1]`
- 所以 `ans = 1 + break`


---

#### 為什麼 swap 只需要看少數 pair？

每次 swap 只會改變兩個數字的位置：`u`、`v`  
所以只有 `pos[u]`、`pos[v]` 會變，其它 `pos[x]` 都不變。

而每個斷點只看 `(i, i+1)` 這種**相鄰數值對**，所以：

- 一個 pair `(i,i+1)` 會改變，必須 `i` 或 `i+1` 是 `u` 或 `v` 才可以
- 含 `u` 的相鄰數值對只有：
  - `(u-1, u)` &rarr; 表示 `u` 為右鄰
  - `(u, u+1)` &rarr; 表示 `u` 為左鄰
- 含 `v` 的相鄰數值對只有：
  - `(v-1, v)` &rarr; 表示 `v` 為右鄰
  - `(v, v+1)` &rarr; 表示 `v` 為左鄰

所以每次 swap 只可能影響最多 4 個相鄰數值對（去重後）

---

#### 更新技巧：先扣舊貢獻，再加新貢獻（局部重算）

令 `affected` 為這次 swap **可能**影響到的相鄰數值對集合：

- `(u-1,u)`, `(u,u+1)`, `(v-1,v)`, `(v,v+1)`（邊界要檢查，並去重）

做法：

1. **swap 前**：用舊 `pos` 計算 `affected` 裡哪些是斷點，先把它們對 `ans` 的貢獻扣掉。所以 `ans--`
2. **做 swap 並更新** `arr` 與 `pos`
3. **swap 後**：用新 `pos` 再算一次 `affected` 裡哪些是斷點，把新貢獻加回來。所以 `ans++`
> `ans` 就是我們的 `round` 數
