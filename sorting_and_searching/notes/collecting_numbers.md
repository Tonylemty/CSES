### 題目意思
* 給定一個包含 `1 ~ n` 的陣列，順序是亂的
* 要依序拿到 `1 -> 2 -> 3 -> ... -> n`
* 每一輪只能**從左到右**，不能回頭
* 問：總共要從左走到右幾次

### 核心概念
* 使用 `vector` 陣列紀錄每一個數字的位置 `pos[x] = i`
* **至少需要一輪** &rarr; `rounds = 1`
* 如果 `pos[k] > pos[k + 1]`，表示下一個數在左邊，一定要開新的一輪
* 原理：
  * `vector` 的索引代表數字 `1 ~ n`，存的是每個數字在原陣列的位置。
  * 當 `pos[k] < pos[k+1]` 時，代表下一個數在右邊，可以在同一輪拿到。
  * 若 `pos[k] > pos[k+1]`，代表下一個數在左邊，但一輪只能從左走到右，不能回頭，因此必須開新的一輪。
