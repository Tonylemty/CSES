### 題目意思
* 給定 `n` 個區間，每個區間皆由左邊界 `l` 和右邊就 `r` 組成 `[l, r]`
* 如果區間 A $[a, b]$ 完全涵蓋區間 B $[c, d]$，也就是滿足 $ a \leq c$ 且 $d \leq b$
* 目標：依照原始輸入順序，針對每個區間輸出兩行是非題答案（是為 `1`，否為 `0`）
  * 包住別人（contains）：這個區間有沒有完整包住「至少一個」其他的區間
  * 被別人包住（contained）：這個區間有沒有被「至少一個」更大的區間完整包在裡面

### 核心概念
* 因為排序會將陣列打亂，但題目要求「原輸入順序輸出答案」
  * 使用 `struct`，把左邊界 $l$、右邊界 $r$、以及它原本是第幾個輸入的 `id` 存在一起
* 排序規則：
  * 左邊界 $l$ 由**小到大**排序 &rarr; 確保我們從左掃到右時，左邊界永遠符合 $l_{前} \le l_{後}$ 的條件
  * 當左邊界相同時，右邊界由**大到小**排序 &rarr; 確保同樣起點的區間，範圍最大的會排在最前面，才能順利判斷它包住了後面較小的區間
* 任務 A：檢查「有沒有被別人包住」(Contained by)
  * 方向：從左到右掃描
  * 維護極值：記錄目前看過「最大的右邊界 (max_r)」
  * 判斷邏輯：因為左邊界已經確定比較大（或相等）了，如果當下區間的 $r \le \text{max\_r}$，代表前面出現過一個比我長、能完全覆蓋我的傢伙！$\rightarrow$ 標記為 1
* 任務 B：檢查「有沒有包住別人」(Contains)
  * 方向：改從右到左掃描（倒著看回來）
  * 維護極值：記錄目前看過「最小的右邊界 (min_r)」
  * 判斷邏輯：因為是從右邊往回看，我現在看的區間，其左邊界一定比較小（或相等且右邊界更大）。這時如果當下區間的 $r \ge \text{min\_r}$，代表我成功包住了我右邊的某個小傢伙！$\rightarrow$ 標記為 1
* 自己的理解：
  * 從左到右的掃描：
    因為我們已經事先透過我們要的排序規則進行排序了，所有從左到右的左邊界一定會是 `<=` 的情況，所以只要去紀錄最長的右邊界，就可以直接確定此區間是否有在其他區間中，因為右邊區間的左邊界必定是 `>=` 左邊區間的左邊界的
  * 從右到左掃描：
    和上面同理，因為已經排好序，當我們從右往左掃描時，已經掃過的「右邊區間」，其左邊界必定 $\ge$ 「當前區間」的左邊界。因此，我們不用管左邊界有沒有相等，只要去紀錄右邊出現過「最短的右邊界 (`min_r`)」。當前區間只要確認一件事：如果我的右邊界 $\ge$ `min_r`，就代表我的尾巴夠長，絕對能把右邊那個最短的區間完整包在裡面