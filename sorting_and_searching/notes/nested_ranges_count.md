### 題目意思
* 給定 `n` 個區間，每個區間有左邊界 `l` 和右邊界 `r`
* 對每個區間都要輸出兩個整數（照原始輸入順序）：
	* 包住別人的數量（contains）：這個區間完整包含了多少個其他區間
	* 被別人包住的數量（contained）：這個區間被多少個其他區間完整包含
* 區間 A $[a, b]$ 完整包含區間 B $[c, d]$ 的條件是 $a \leq c$ 且 $d \leq b$

### 核心概念
1. 綁定身分與自訂排序 (Struct & Custom Sorting)
   * 綁定 ID：用 `struct` 記住每個區間一開始輸入的 `id`，方便最後依序輸出答案。
   * 核心排序規則：
     * 主要：左邊界 $l$ 由小到大排。
     * 次要：當左邊界相同時，右邊界 $r$ 由大到小排。（確保範圍最大的在前面 
2. 準備計數神器：PBDS (Policy Based Data Structure)
   * 為什麼用它？ 我們需要在掃描的過程中，不斷把看過的右邊界丟進箱子，並且能瞬間回答：「箱子裡有幾個數字大於/小於我？」PBDS 的 `order_of_key` 可以在 $O(\log N)$ 內完美解決這件事。
   * 避坑技巧：PBDS 本質是 Set，不收重複的數字。所以我們必須存入 `pair<int, int>`，也就是 `{右邊界 r, 區間的 id}`，讓每一個右邊界都變成獨一無二的個體。
3. 雙向掃描線 (Sweep Line)
   * 任務 A：計算「被幾個包住」(Contained by)
     * 方向：由左掃到右 ($0 \to n-1$)。
     * 邏輯：因為左邊界已經確定比較小或相等，只要問 PBDS：「裡面有幾個右邊界 $\ge$ 我的右邊界？」
     * 語法：`總數 - pbds.order_of_key({我的 r, -1})` 
     * 動作：查完答案後，把自己的 `{r, id}` 塞進 PBDS。
   * 任務 B：計算「包住幾個別人」(Contains)
     * 準備：先將 PBDS 清空 (`pbds.clear()`)。
     * 方向：由右掃到左 ($n-1 \to 0$)。
     * 邏輯：因為右邊的左邊界一定比較大或相等，只要問 PBDS：「裡面有幾個右邊界 $\le$ 我的右邊界？」
     * 語法：`pbds.order_of_key({我的 r, 1e9})`
     * 動作：查完答案後，把自己的 `{r, id}` 塞進 PBDS。
